# 面向对象编程

## 1. 创建一个基本的 JavaScript 对象

想想我们在生活中每天都可见到的事物：比如汽车、商店以及小鸟等。 它们都是*对象*：即人们可以观察和与之互动的实体事物。

这些物体的性质是什么？ 汽车有轮子。 商店销售物品。 鸟儿有翅膀。

这些特征，或者说是*属性*定义了一个对象由什么构成的。 需要注意的是：那些相似的对象可以拥有相同的属性，但是这些属性可能会有不同的值。
举个例子：所有的汽车都有轮子，但并不是所有汽车的轮子个数都是一样的。

JavaScript 中的对象可以用来描述现实世界中的物体，并赋予他们属性和行为，就像它们在现实世界中的对应物一样。
下面是使用这些概念来创建一个 `duck` 对象的示例：

```javascript
let duck = {
    name: "Aflac",
    numLegs: 2
};
```

这个 `duck` 对象有两组键值对：一个是 `name` 属性，它的值是 `Aflac`；另一个是 `numLegs` 属性，它的值是 `2`。

[练习](./createBasicObject.js)

## 2. 使用点符号来访问对象的属性

之前的挑战创建了一个具有各种属性的对象。 现在你会看到如何访问这些属性的值。 下面是一个示例：

```javascript
let duck = {
    name: "Aflac",
    numLegs: 2
};
console.log(duck.name);
```

我们可以用“点号表示法”来访问对象的属性，`duck` 后面加上点号以及属性名 `name`，来访问到 `Aflac`。

[练习](./dotAccess.js)

## 3. 在对象上创建方法

对象可以有一个叫做 _method_ 的特殊属性。

方法属性也就是函数。 这给对象添加了不同的行为。 以下就是一个带有方法属性的 `duck` 示例：

```javascript
let duck = {
    name: "Aflac",
    numLegs: 2,
    sayName: function () {
        return "The name of this duck is " + duck.name + ".";
    }
};
duck.sayName();
```

示例添加了 `sayName` 方法，函数返回包含 `duck` 名字的一个句子。 注意：这个方法在返回语句中使用 `duck.name`
的方式来获取 `name` 的属性值。 在下一个挑战中我们将会使用另外一种方法来实现。

[练习](./objectMethod.js)

## 4. 使用 this 关键字提高代码重用性

在上一个挑战中我们了解了该如何给 `duck` 对象设置一个方法。 然后在 `return` 语句里，我们通过使用 “点号表示法” `duck.name`
来获取 `name` 的属性值：

```javascript
sayName: function () {
    return "The name of this duck is " + duck.name + ".";
}
```

虽然这是访问对象属性的有效方法，但是这里有一个陷阱。 如果变量名发生了改变，那么引用了原始名称的任何代码都需要更新。
在一个简短的对象定义中，这并不是问题，但是如果对象有很多对其属性的引用，那么发生错误的可能性就更大了。

我们可以使用 `this` 关键字来避免这一问题：

```javascript
let duck = {
    name: "Aflac",
    numLegs: 2,
    sayName: function () {
        return "The name of this duck is " + this.name + ".";
    }
};
```

`this` 是一个很复杂的知识点，而上面那个例子也只是使用它的一种方法而已。 在当前的上下文环境中，`this`
指向的就是与这个方法有关联的 `duck` 对象。 如果把对象的变量名改为 `mallard`，那使用 `this` 后就没有必要在代码中找到所有指向
duck 的部分。 这样可以使得代码更具有可读性和复用性。

[练习](./thisKeywordForCodeReuse.js)

## 5. 定义构造函数

_Constructors_ 是创建对象的函数。 函数给这个新对象定义属性和行为。 可将它们视为创建的新对象的蓝图。

以下就是一个构造函数的示例：

```javascript
function Bird() {
    this.name = "Albert";
    this.color = "blue";
    this.numLegs = 2;
}
```

这个构造函数定义了一个 `Bird` 对象，其属性 `name`、`color` 和 `numLegs` 的值分别被设置为 Albert、blue 和 2。 构造函数遵循一些惯例规则：

* 构造函数函数名的首字母大写，这是为了方便我们区分构造函数（ `constructors`）和其他非构造函数。
* 构造函数使用 `this` 关键字来给它将创建的这个对象设置新的属性。 在构造函数里面，`this` 指向的就是它新创建的这个对象。
* 构造函数定义了属性和行为就可创建对象，而不是像其他函数一样需要设置返回值。

[练习](./defineConstructor.js)

## 6. 使用构造函数创建对象

在上一个挑战中，我们用所学到的知识创建了一个 `Bird` 构造函数：

```javascript
function Bird() {
    this.name = "Albert";
    this.color = "blue";
    this.numLegs = 2;
}

let blueBird = new Bird();
```

**注意：** 构造函数内的 this 总是指被创建的对象。

**注意：** 通过构造函数创建对象的时候要使用 `new` 操作符。 因为只有这样，JavaScript 才知道要给 `Bird`
这个构造函数创建一个新的实例：`blueBird`。 如果不使用 `new` 操作符来新建对象，那么构造函数里面的 `this`
就无法指向新创建的这个对象实例，从而产生不可预见的错误。 现在 `blueBird` 这个实例就继承了 `Bird` 构造函数的所有属性，如下：

```javascript
blueBird.name;
blueBird.color;
blueBird.numLegs;
```

由构造函数创建的实例也和其他对象一样，它的属性可以被访问和修改：

```javascript
blueBird.name = 'Elvira';
blueBird.name;
```

[练习](./objectConstructor.js)

## 7. 扩展构造函数以接收参数

上一个挑战中 `Bird` 和 `Dog` 构造函数运行得不错。 但是，注意到没有：所有通过 `Bird` 构造函数创建出来的实例 `Birds` 都自动的取名为
Albert，颜色都是蓝色，还都有两条腿。 如果你想要新创建出来的小鸟们拥有不同的名字和颜色要怎么办呢？
当然，手动的去修改每一个小鸟实例自己的属性也是可以实现的，只是会增加很多无谓的工作量：

```javascript
let swan = new Bird();
swan.name = "Carlos";
swan.color = "white";
```

假如你写了一个程序来追踪一个鸟舍里面的几百只甚至几千只不同的小鸟。 你将会花费很多时间去创建所有的小鸟实例并给它们的属性一一修改为不同的值。
为了减轻创建不同 Bird 对象的工作量，你可以给你的 `Bird` 设置为可以接收参数的构造函数：

```javascript
function Bird(name, color) {
    this.name = name;
    this.color = color;
    this.numLegs = 2;
}
```

然后将值通过参数的方式传递给 `Bird` 构造函数来定义每一个唯一的小鸟实例： `let cardinal = new Bird("Bruce", "red");`
这给 `Bird` 的 `name` 和 `color` 属性分别赋值为 `Bruce` 和 `red` 色。 但 `numLegs` 属性仍然设置为 2。 `cardinal`
有以下这些属性:

```javascript
cardinal.name
cardinal.color
cardinal.numLegs
```

这样一来构造函数就变得很灵活了。 现在可以在创建每个 `Bird` 实例时直接定义属性，这是 JavaScript 构造函数非常实用的用法之一。
它们根据共同或相似的属性和行为将对象归纳为一组，并能够自动的创建各自实例。

[练习](./parameterizedConstructor.js)